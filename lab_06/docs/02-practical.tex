\section*{Задание 1}
\subsection*{Постановка задачи}
Написать хвостовую рекурсивную функцию my-reverse, которая развернет верхний
уровень своего списка-аргумента lst.

\begin{lstlisting}
(defun move-to (lst res) (cond ((null lst) result)
(T (move-to (cdr lst) (cons (car lst) result)))))
\end{lstlisting}

\section*{Задание №2}
Написать функцию, которая возвращает первый элемент списка-аргумента, который сам
является непустым списком.

\begin{lstlisting}
(defun flistp (lst) (cond ((null (car lst)) Nil)
((listp (car lst)) (car lst))
(T (fnotnull(cdr lst)))))

\end{lstlisting}



\section*{Задание №3}
Написать функцию, которая выбирает из заданного списка только те числа, которые
больше 1 и меньше 10.

(Вариант: между двумя заданными границами. )
\subsection*{Решение}
\begin{lstlisting}[label=third,caption=Решение задания №3, language=lisp]
(defun select-between (lst left right) (cond ((null lst) Nil)
((and (< (car lst) right) (> (car lst) left)) (nconc (list (car lst)) (select-between (cdr lst) left right)))
(T (select-between (cdr lst) left right)) ))
\end{lstlisting}

\section*{Задание №4}
Напишите рекурсивную функцию, которая умножает на заданное число-аргумент все
числа
из заданного списка-аргумента.

\subsection*{Решение}
Все элементы списка --- числа.
\begin{lstlisting}[label=third,caption=Решение задания №3, language=lisp]
(defun prod (lst num) (cond ((null lst) Nil)
(T (nconc (list (* (car lst) num)) (prod (cdr lst) num)))))
\end{lstlisting}

Элементы списка -- любые объекты.
\begin{lstlisting}[label=third,caption=Решение задания №3, language=lisp]
(defun prod (lst num) (cond ((null lst) Nil)
((listp (car lst)) (nconc (list (prod (car lst) num)) (prod (cdr lst) num)))
(T (nconc (list (* (car lst) num)) (prod (cdr lst) num)))))
\end{lstlisting}

\section*{Задание №5}
Напишите функцию, select-between, которая из списка-аргумента, содержащего только
числа, выбирает только те, которые расположены между двумя указанными границами-
аргументами и возвращает их в виде списка (упорядоченного по возрастанию списка чисел
(+ 2 балла)).

\subsection*{Решение}
\begin{lstlisting}[label=5,caption=Решение задания №5, language=lisp]
(defun select-between (lst left right) (cond ((null lst) Nil)
((and (< (car lst) right) (> (car lst) left)) (nconc (list (car lst)) (select-between (cdr lst) left right)))
(T (select-between (cdr lst) left right)) ))

\end{lstlisting}


\section*{Задание №6}
Написать рекурсивную версию (с именем rec-add) вычисления суммы чисел заданного
списка.
\subsection*{Решение}

Одноуровневый смешанный список.
\begin{lstlisting}[label=5,caption=Решение задания №5, language=lisp]

(defun add (lst res) (cond ((null lst) res) 
((numberp (car lst)) (add (cdr lst) (+ (car lst) res)))
(t (add (cdr lst) res))))

(defun rec-add (lst) (add lst 0))

\end{lstlisting}

Структурированный список.

\begin{lstlisting}[label=5,caption=Решение задания №5, language=lisp]

(defun add (lst res) (cond ((null lst) res) 
((numberp (car lst)) (add (cdr lst) (+ (car lst) res)))
((listp (car lst)) (let ((tmp (add (car lst) 0))) (add (cdr lst) (+ tmp res)) ))
(t (add (cdr lst) res))))

(defun rec-add (lst) (add lst 0))

\end{lstlisting}




\section*{Задание №7}
Написать рекурсивную версию с именем recnth функции nth.
\begin{lstlisting}[label=5,caption=Решение задания №5, language=lisp]
(defun recnth (lst ind) (cond   ((null lst) nil)
((= ind 0) (car lst))
(T (recnth (cdr lst) (1- ind)))))

\end{lstlisting}

\section*{Задание №8}
Написать рекурсивную функцию allodd, которая возвращает t когда все элементы списка
нечетные.
\subsection*{Решение}
\begin{lstlisting}[label=5,caption=Решение задания №5, language=lisp]
(defun sum-sizes (lst) 

(defun sub (lst res) (cond ((null lst) res)
(T (sub (cdr lst) (and (oddp (car lst)) res)))))

(defun allodd (lst) (sub lst T))

\end{lstlisting}	

\section*{Задание №9}
Написать рекурсивную функцию, которая возвращает первое нечетное число из списка
(структурированного), возможно создавая некоторые вспомогательные функции.
\subsection*{Решение}
\begin{lstlisting}[label=5,caption=Решение задания №5, language=lisp]
(defun sum-sizes (lst) 
(defun fodd (lst) (cond ((null lst) nil) 
((numberp (car lst)) (if (oddp (car lst)) (car lst) (fodd (cdr lst))))
((listp (car lst)) (let ((tmp (fodd (car lst)))) (if (null tmp) (fodd (cdr lst)) tmp)))
(T (fodd (cdr lst)))))

\end{lstlisting}	

\section*{Задание №10}
Используя cons-дополняемую рекурсию с одним тестом завершения,
написать функцию которая получает как аргумент список чисел, а возвращает список
квадратов этих чисел в том же порядке
\subsection*{Решение}
\begin{lstlisting}[label=5,caption=Решение задания №5, language=lisp]
(defun sqr (lst res) (cond ((null lst) res)
((numberp (car lst)) (sqr (cdr lst) (cons (* (car lst) (car lst)) res)))
((listp (car lst)) (sqr (cdr lst) (cons (sqr (reverse (car lst)) ()) res)))
(T (sqr (cdr lst) res))))

(defun my-sqr (lst) (sqr (reverse lst) ()))

\end{lstlisting}
\begin{lstinputlisting}[label=third,caption=Решение задания №9, language=lisp, firstline=1, lastline=1]{../lab.lisp}
\end{lstinputlisting}